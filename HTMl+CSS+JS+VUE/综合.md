#### 行内元素和块元素的区别？
  (1)行内元素默认在同一行排列，而块元素会另起一行。
  (2)行内元素一般只包含行内元素，而块元素可以包含任何元素。
  (3)块元素宽高 margin padding设置都有作用，宽度默认是100%，行内元素宽高是不可设置的，由内容决定的。
  (4)display可以设置元素转换成块或者是行内。

#### 浏览器渲染原理
  浏览器收到文件后会先生成一个DOM树，然后把css文件生成一个CSSOM树，有了这两棵树以后，将两棵树组成渲染树，然后调用GPU来绘制。
  补充：为什么说DOM操作比较慢，因为js是js引擎中执行的东西，而DOM渲染是渲染引擎中的东西，用js操作DOM就需要两个线程相互通信，并且很可能会带来重绘。
  重绘是指更改节点外观不更改布局，回流是布局需要改变。回流必定引起重绘，而重绘不一定会引起回流的。

#### 盒模型包括哪些东西，又分为哪两种盒模型。
  盒模型包括 content padding border margin。
  标准盒模型 设置width 和height的时候指的是content的宽高。
  IE盒模型设置宽高包括border content padding。  通过box sizing border box来设置。

css的字体相关属性是可以继承的。

css选择器的优先级 最高的是声明！impotent  然后是行内 然后是id  然后是类 然后才是伪类伪元素。

css常见的居中方法。
    一般常见的几种居中的方法有：

  对于宽高固定的元素

  （1）我们可以利用margin:0 auto来实现元素的水平居中。

  （2）利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水
  平和垂直方向上的居中。

  （3）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素
  的中心点到页面的中心。

  （4）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素
  的中心点到页面的中心。

  （5）使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对
  齐，然后它的子元素也可以实现垂直和水平的居中。

  对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。

#### css的BFC
  BFC可以看作元素的一个属性，他能让元素成为一个独立的渲染区域，不影响其他的元素，overflow hidden等可以触发bfc。
  bfc一般用来解决margin合并的问题  清除浮动  避免浮动元素覆盖其他元素

#### css的定位问题
  absolute 根据最近的一个被设置 relative 或者absolute的元素定位，一般给他的父元素设置相对定位来实现。会脱离文档流，如果设置偏移量会影响到其他元素。
  relative 根据自己本身的位置来定位，还是在文档流中的，不影相邻的其他元素。
  static 默认的定位。
  fixed 根据浏览器窗口的绝对定位。

#### 25.'display'、'position'和'float'的相互关系？


（1）首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。

（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被
设置为table或者block，具体转换需要看初始转换值。

（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display
的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对
于浮动后的最终位置定位。

（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，
则保持指定的display属性值不变。

总的来说，可以把它看作是一个类似优先级的机制，"position:absolute"和"position:fixed"优先级最高，有它存在
的时候，浮动不起作用，'display'的值也需要调整；其次，元素的'float'特性的值不是"none"的时候或者它是根元素
的时候，调整'display'的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display'特性值同设置值。


margin重叠问题 上下两个元素一般统一设置上或者下的margin  父子元素一般给父元素上padding来解决。

#### 响应式布局的方法：
  （1）通过flex的伸缩来改变盒子的大小
  （2）rem是根字体的倍数大小，可以通过获取屏幕尺寸算出来根字体大小，然后设置rem的值。

  opacity: 0、visibility: hidden、display: none 的使用场景和区别？
  第一个是透明度  第二个设置元素不可见 但是其实还占用空间影响布局  第三个是元素直接删除了，不会占用空间

#### var let const 的区别
  var声明的变量是函数作用域  而let声明的变量是块作用域，
    if(){ 这里就是块作用域 } function a(){ 这里就是函数作用域 }
  var声明的变量有提升作用  ler没有提升
  var在全局作用域中声明变量会成为window对象的属性，而let不会
  
  const声明必须赋值，且引用值不可修改，如果声明的是对象 数组 则修改里面的值没有任何问题。
  例如 
      const r = {name:'小王'}  r.name = 小张  //正确  
      const r = 1  r = 2                    //错误
  在使用时 尽量使用const  如果这个值一定需要修改才改成let  var则放弃使用

#### js数据类型问题
  undefined
   如果一个变量只是声明没有赋值的情况下 会默认赋值undefined。undefined是一个特殊的数据类型，但是有个问题需要主义 使用typeof的时候 声明未赋值的变量和未声明的变量都会是undefined 所以为了避免这个情况出现，声明变量时最好是先赋值。
  null 
    null代表一个空对象，const r = null type t //object 如果一个变量被赋值null typeof他会输出object 是因为null代表了一个空对象，所以在声明一个空对象时可以赋值null。需要注意的是null == undefined这个表达式会判定为true
  Boolean
    布尔值有两个选项 真值true 假值false  需要注意的是if语句会自动把其他数据类型转为布尔值  例如  if(1) {这里会执行} if(0){这里不会执行}  if(null){不会执行}  这里不代表1等于true 只是1通过类型转换成布尔值的结果是true。下面给出会转换成false的值:0 ,""(空字符串),null,undefined。相反的是 任意非0数字，任意对象，非空字符串都可以转换成true。
  
  #### js原型
    构造函数访问自己的原型 函数名.prototype的方式  而实例用 实例名._proto_的方式来访问。实例自己的原型就是构造自己的构造函数的原型，原型链的最上层就是 Object  而Object原型的原型是null。
    
    1.什么是原型 ？
      了解原型之前我们需要明白另外一件事情，什么是构造函数。
        function student(){}  这是一个函数 
        我们可以直接调用它  student() 因为它的函数体是空的 所以不会执行任何操作。
        但我们还有另外一种办法调用它 那就是new 
          let a = new student()
        这句代码意思是 创建一个 student 类型的对象 a  把student()函数当构造函数使用，其实所有的函数只要使用new 来调用都是构造函数，反过来说构造函数和函数的区别就是是否用new来调用。

      每个函数都有一个属性 prototype 这是一个对象，有一个默认属性 constructor 指针 指向函数本身。
      如果我们给函数的原型对象设置一些属性，那么通过这函数new出来的对象就会拥有这些属性。
        上代码
          function student(){};
          student.prototype.name = '二狗';
          let a = new student();
          console.log(a.name); // 二狗
        这是为什么呢，因为通过构造函数创造的实例 默认有一个原型属性 就等于创建它的构造函数的原型，而我们访问 name属性的时候  js引擎先去a这个对象里找name属性 没有找到 就往上去找他的原型对象有没有name属性，结果找到了，就输出。
### js函数
    js函数的参数可以随便传多少个，和函数的参数列表没有关系，在函数中可以通过arguments这数组来访问所有传入的参数。这里注意箭头函数中没有这个arguments对象。
    this的指向问题，在传统函数中this的指向必须等到调用时才能确定，本意是谁调用指向谁。
    而箭头函数中的this指向定义该函数时的上下文,如果函数在全局定义的，那么this指向window对象，如果函数在对象里面定义的 那么函数指向此对象
    目前得到的答案是 this在箭头函数中指向window对象 在被另外一个函数包裹时候 他的this等于包裹他函数的this。

    函数的call 和apply bind属性
      apply 接受两个参数 第一个是this值 第二个是一个参数数组 或者arguments对象
      call 参数不固定 第一个是this  后面的是一个个的参数 其他和apply一样
      如果要传的参数很少或者没用就用call  如果参数很多传arguments对象或者数组 用apply
      bind 会创建一个新的函数实例 并把this对象绑定到传入的对象中。

   闭包
    闭包的意思就是 子函数可以访问父函数的参数
    说白了就是作用域链的问题
    一般用里面的函数访问外面函数的变量
    或者利用闭包属性把父函数的变量保存在内存中不会因为函数结束而回收，因为js 垃圾回收机制是根据上下文标记的，如果存在能引用此变量的上下文那么就不会回收这个变量。
    ```
      function father (){
        const r = 10;
        function son(){
          console.log(r); // 10
        }
      }
    ```
    通过这个特性 我们可以给一个箭头函数更多的参数
    例如 查找数组中 给定两数之间的数
    ```
      const list = [1,2,3,4,5,6,7,8,9];
      function bet(a,b){
        return (item)=>{
          return item > a && item < b;
        }
      }

      list.filter(bet(1,5))

      因为这里filter需要一个函数当作参数，但是这个函数的参数又是不能多添加的，我们又需要指定变量，则闭包的作用就出现了。
    ```

### js promise 异步
    首先要确定的是js是单线程执行的，也就是说所有的代码都是再一个线程内顺序执行的，所谓的异步都是用单线程模拟出来的。
    js在浏览器环境运行的时候有以下几个东西  运行栈（顺序执行代码的地方） 任务队列（回调函数存放的地方） webApi（setTimeOut 和 各种网络请求都是浏览器提供的）

    那么执行的顺序是 同步代码放入 运行栈中执行 如果遇到 setTimeOut等异步操作 那么就交给webApi来处理 运行栈继续执行下面的代码 webApi处理完异步操作后，会把回调函数放入任务队列。

    接下来介绍的就是 event loop 事件循环机制 其实就是js引擎先执行 运行栈中的代码  等运行栈中所有代码执行完毕为空时 则去检查任务队列 如果任务队列中有需要执行的任务就依次执行到完毕，然后再去检查运行栈中是否有代码需要执行 如此反复。

    那么定时任务是如何定时的呢，定时任务交给webApi时会创建一个计时器，等计时结束的时候才会把回调函数添加到任务队列。那么由此可见的是设置的定时任务不一定会按照定时的时间去执行的 需要考虑 栈中代码是否执行完毕 任务队列中是否有其他任务。所以定时任务并不是指定多久后执行，而是最快多久执行。

    @click也算是异步任务，在js执行到这段代码的时候就会把@click的事件放在webApi中 当你点击时 WebApi就会添加指定的函数到任务队列中。

    不要在栈中添加过多的耗时代码，因为浏览器每16毫秒会渲染一次，但是前提是栈空间为空才可以执行重新渲染。

    async await 是语法糖 代表的是一个异步函数 这个异步函数会等待await后面的promise执行完毕才会继续往下执行。

### js 防抖 节流
    防抖是函数在触发后n秒后再执行 如果执行前再次触发则重新计时   具体做法 利用计时器来解决 关键思想是清除上一个定时任务  重新开启一个新的定时任务。
    ```
        // 防抖
    function debounce(fn, delay) {
      let timer;
      return function () {
        clearTimeout(timer);
        timer = setTimeout(() => {
          fn.apply(this, arguments);
        }, delay);
      };
    }
    ```

    节流则是单位时间内触发的操作只有第一次执行，实现方式是 利用定时器 定时器初始为null 只有定时器为null的时候才会开启一个定时任务 并且赋值给定时器 在定时任务代码里把定时器值赋空 这样只有第一次和定时任务执行完毕后 定时器的值才会为null 定时器为null时才会开启新的定时任务。

    ```
        // 节流
    function throttle(fn, delay) {
      let timer = null;
      return function () {
        if (timer == null) {
          timer = setTimeout(() => {
            fn.apply(this, arguments);
            timer = null;
          }, delay);
        }
      };
    }

    ```

### js 数组和对象的一些内置方法使用

### vue2 笔记
    1.data为什么要return出去？
        vue每个页面都是一个组件 组件的data是一个函数 是因为这要实现深拷贝 让每个组件维护自己的数据。

    2.vue组件的父子通讯
        vue子组件发送事件用 @click='$emit('事件名')'  父组件监听@事件名 = '要触发的函数'

    3. v-model 的原理 
        v-model 的原理就是动态绑定加上监听input事件，在input事件发生的时候把拿到的数据赋值给绑定的数据，用在组件上也是监听子组件默认发送出来的input事件

    4.计算属性vs方法  侦听属性 watch
        计算属性只有在响应式的数据发生变化的时候才会重新计算，如果数据没有变化重新调用的话，就是调用上次的缓存，并不会重新执行一次。
        方法每次调用都会执行一次。
        侦听属性 watch 用来监听属性进行异步操作或开销过大的时候使用。

    5.数组
        this.list[0] = '新的值'；
        上面根据数组下标修改值的动作vue监听不到不会发生响应式，需要用 this.$set(this.list,0,'新的值') 来实现响应式。

    6.生命周期
        created 在这一步的时候 数据和方法都已经初始化好了，所以最早的调用方法和数据的事件就是这里。
        mounted 执行完这一步整个vue实例就初始化完毕了，组件已经脱离了创建阶段，进入到了运行阶段。在这一阶段就可以操作DOM对象了。
        父子组件声明周期过程都是 父先开始 子先结束  父组件可以监听子组件的钩子函数。
    
    7.响应式的实现原理。
        利用js 对象的访问器属性的getter和setter拦截数据变化做出响应。 数组的监听就是重写了数组的一些方法 用户调用数组的方法时就走的自己的方法通知视图去更新。更改了数组的原型

    8.虚拟DOM
        每次操作DOM会有很大的开销，每更新一次就要重新计算一次，虚拟DOM就是用js对象来模拟DOM 然后把DOM操作集中在一起更改，这样就不用重复计算。
    
    9.v-if v-for 不一起用的原因。
        v-for的优先级比v-if高 会把不展示的元素遍历出来再删去，开销比较高。

    10.v-for key的作用。
        主要是给Vue的虚拟DOM算法区分更改的DOM 高效的更新虚拟DOM。

    11.vue 如何获取DOM
        设置一个ref名.this.$ref.名字。 放在组件上面可以拿到组件的属性。

### https的一些基础知识

### webpack 打包工具的基础知识
