### 目录
- [目录](#目录)
- [预备知识](#预备知识)
- [第一章：C++语言简介](#第一章c语言简介)
- [第二章：面向对象的基本概念](#第二章面向对象的基本概念)
- [第三章：类和对象进阶](#第三章类和对象进阶)
- [第四章：运算符重载](#第四章运算符重载)
- [第五章：类的继承与派生](#第五章类的继承与派生)
- [第六章：多态与虚函数](#第六章多态与虚函数)

### 预备知识
      数组概念
        特点1.数组中每个数据元素都是相同的数据类型
        特点2.数组是由连续的内存位置组成的
      一维数组数组定义方式
        1.数据类型   数组名[数组长度]；
        2.数据类型   数组名[数组长度] = {值1，值2…}；
        3.数据类型   数组名[ ] = {值1，值2…}；
      
        
      指针的概念
        指针可以间接访问内存，定义指针的语法：     数据类型 * 变量名
        例 int * p = &a；这里&为取址符号。
        使用指针：可以通过解引用的方法来找到指针指向的内存，指针前加*代表解引用 例 *p = 1000 此时 输出*p和a都等于1000
      const修饰指针有三种情况：
        1.const修饰指针---常量指针
          cost int * p = &a；
          特点：指针的指向可以修改，但是指针指向的值不可以改。
              *p = 20；错误，值不可以修改
              *p = &b；正确，指向可以修改 
        2.const修饰常量---指针常量
          int * const p = &a；
          特点：指针指向不可以修改，指针指向的值可以修改。
              *p = 20；正确，值可以修改
              *p = &b；错误，指向不可以修改
        3.const既修饰指针，又修饰常量
          const int * const p = &a；
          特点：指针的指向和指针指向的值都不可以修改
              *p = 20；错误，值不可以修改
              *p = &b；错误，指向不可以修改
        记忆方法：const=常量 * = 指针 const在前就是常量指针，const在后就是指针常量，const限定的那个不能修改，const在前修饰的就是* p 所以*p的值不可以更改，const在后修饰的就是p也就是说指针的指向不可以修改。
        
      指针和数组
        指针和数组，指针可以访问数组，指针直接=数组的名字就是指向数组的首项，这个时候解引用输出就是数组的首项值，如果让p++就指向数组的第二项。
        
      指针和函数
        利用指针做函数参数，可以修改实参的值。

### 第一章：C++语言简介
    一，基本输入和输出流；
      输出cout<<            输入cin>>
      输出多项要用<<隔开，输入多项时要用空格隔开。
      
    二，头文件和命名空间
      #include 是指包括包含的意思，#include<iostream>是指声明标准输入输出流，如果需要用到cout cin 必须在头文件声明iostream，如还需用到其他内容则需要包含其他的头文件，每个include指令只能包含一个头文件。
      常用头文件
        标准输入输出流：<iostream>
        标准文件流：<fstream>
        标准字符串处理函数：<string>
        标准数学函数：<cmath>
      程序员可以自己定义头文件，用尖括号的是系统提供头文件，双引号是程序员自己定义的头文件。
      using namespace std 表示使用命名空间std，命名空间的作用是为了消除同名引起的歧义。
      
    三，强制类型转换运算符
      static-cast const-cast
      
    四，函数参数的默认值
      在声明函数时可以为形参指定默认值，当调用有默认值的函数时调用语句可以不给出对应的实参，不给就相当于使用函数默认值，给几个就用几个给的参数，没有给到的还是用默认值。
      函数形参赋值从右侧开始，如果右侧没有左侧也不允许有默认值。
      
      
    五，引用和函数参数的传递
      引用的定义
              类型名 &引用名 = 同类型的某变量名（普通引用）
              const int &cname = onelnt；（常引用）
        这样操作之后引用名和同类型的变量名值一样，对应的内存地址也一样，同一个变量的引用可以有很多个。
        普通引用和常引用的区别为：普通引用可以通过对引用名修改值来同时修改被引用变量的值，而常引用不可以。
        注意：引用的时候必须初始化，一旦初始化之后不能更改。
      引用在函数中的使用
        引用可以作为函数的参数和返回值。
        函数参数采用引用的方式的时候，形参会修饰实参，如果不采用引用的范式，形参不会修饰实参。（具体参考书本例子）
        函数返回值采用引用的方式，可以让函数做为左值。（具体参考视频）
        
    六，const与指针共同使用
      指针的概念
        指针可以间接访问内存，定义指针的语法：     数据类型 * 变量名
        例 int * p = &a；这里&为取址符号。
        使用指针：可以通过解引用的方法来找到指针指向的内存，指针前加*代表解引用 例 *p = 1000 此时 输出*p和a都等于1000
      const修饰指针有三种情况：
        1.const修饰指针---常量指针
          cost int * p = &a；
          特点：指针的指向可以修改，但是指针指向的值不可以改。
              *p = 20；错误，值不可以修改
              *p = &b；正确，指向可以修改 
        2.const修饰常量---指针常量
          int * const p = &a；
          特点：指针指向不可以修改，指针指向的值可以修改。
              *p = 20；正确，值可以修改
              *p = &b；错误，指向不可以修改
        3.const既修饰指针，又修饰常量
          const int * const p = &a；
          特点：指针的指向和指针指向的值都不可以修改
              *p = 20；错误，值不可以修改
              *p = &b；错误，指向不可以修改
        记忆方法：const=常量 * = 指针 const在前就是常量指针，const在后就是指针常量，const限定的那个不能修改，const在前修饰的就是* p 所以*p的值不可以更改，const在后修饰的就是p也就是说指针的指向不可以修改。
        
    七，内联函数
      内联函数声明时需要用到关键字inline
      内联函数体内不允许有循环语句和switch语句
      内联函数的定义必须出现在第一次被调用之前
      对内联函数不能进行异常接口声明
      内联函数：和正常函数一样调用，只不过编译器发现是内联函数之后就会直接把内联函数的代码贴到你调用的地方，而不在原先的函数里计算了。
      
    八，函数的重载
        允许功能相近的函数在相同的作用域内以相同的函数名声明。
        实现函数重载必须满足下列条件之一：
          参数表中对应的参数类型不同。
          参数表中参数个数不同。
          具有相同函数名的两个及以上的函数，编译器根据形参的类型和个数进行最佳匹配。
        
    九，指针和动态内存分配
      指针变量中保存的是一个地址，有时也称指针指向一个地址。
      int a = 100 ，*p = &a；  如果输出p会得到A的地址，但是输出*p（解引用）会得到100。
      指针和数组，指针可以访问数组，指针直接=数组的名字就是指向数组的首项，这个时候解引用输出就是数组的首项值，如果让p++就指向数组的第二项。
      
      动态申请内存操作符new
        语法：new 类型名T（初始化参数列表）
        功能：在程序执行期间，申请用于存放T类型对象的内存空间，并依初始列表赋以初值。
        结果值：成功 T类型指针，指向新分配内存；失败 抛出异常
      释放内存操作符delete
        语法：delete 指针p   释放数组 delete[]指针；（不带括号只释放首项）
        功能：释放指针p所指向的内存，p必须是new操作的返回值
        
    十，用string对象处理字符串
      要在程序中使用string对象必须包含头文件string，即在程序最前面加上
          #include<string>
      声明string对象的声明
        与声明普通变量类似，string  变量名；可以用各种字符串来初始化，还可以声明一个string对象数组，数组中每个元素都是字符串。
      string对象的操作
        string对象可以用cin和cout进行输入输出
        string对象可以相互赋值，也可以用字符串常量和字符数组来对string赋值，赋值时不用考虑string是否有足够的空间。
        string对象之间可以用<,>,=, == ,!=, <=, >=,来进行比较，大小判断标准按照字典排序进行，大小写相关，大写的Z也要比小写的a大，还可以用+连接string对象。

### 第二章：面向对象的基本概念
    一，面向对象程序设计的特点
      面向对象程序设计有抽象，封装，继承，多态，四个基本特点。
    二，类的定义
      类是用户自定义的数据类型，使用时要先定义这个类型，然后声明对象。
        类的定义格式：
          class 类名（属性，变量形式表现；行为，函数形式表现）
            {
            访问范围说明符；
              成员变量1（成员变量不可以赋值）
              成员变量2
              …
              成员函数声明1
              成员函数声明2
              …
            访问范围K说明符；
              更多成员变量
              更多成员函数声明
              …
            }；
      访问范围说明符：
        public 公有   类内可以访问，类外也可以访问
        private 私有   类内可以访问问，类外不可以访问 
        protected 保护   类内可以访问，类外不可以访问
      在类的定义中可以任意的次序出现任意多次。
      
    三，类的实例程序剖析
      程序结构
        一个完整的c++程序包括以下几部分
            一个主函数，可以调用其他函数，但不能被调用，也称为主程序
          用户定义的任意多个类以及全局函数。
            全局说明。在所有函数和定义之外的变量说明及函数原型
            注释。
            头文件。
      成员变量与成员函数的定义
          成员变量一般定义为私有访问权限，类外访问需要重新定义访问函数。
          类中定义的成员函数允许重载。
        
    四，创建类对象的基本形式
        具有类类型的变量称为对象，完整的定义了类之后，就可以创建对象了，也称为声明 定义 或生成对象。
        定义了类的数据类型只是告诉编译器该数据类型的结构或者框架，并没有分配内存，类只是一个模板，根据这个模板可以在内存中开辟同样结构的实例，即对象，对象是类的实例化。
        定义一个普通对象的基本方法有两种
        方法1：
          类名 对象名；
          类名 对象名（参数）；
          类名 对象名 = 类名（参数）；
        可以扩展为多个对象名（类名 对象1，对象2，…；）
        方法2：
          类名 *对象指针名 = new 类名；
          类名 *对象指针名 = new 类名（）；
          类名 *对象指针名 = new 类名（参数）；
        与基本数据类型一样，还可以声明对象的引用，对象的指针和对象的数组。

    五，访问对象的成员
      使用对象访问成员变量与调用成员函数
        定义了类和对象后就可以通过对象访问成员，格式如下；
          对象名.成员变量名
        调用成员函数的一般格式如下；
          对象名，成员函数名（参数表）
      使用指针访问对象的成员格式如下；
        指针->成员名
      使用引用访问对象的成员格式如下；
        引用名.成员名

    六，类成员的可访问范围
        public 公有   类内可以访问，类外也可以访问
        private 私有   类内可以访问问，类外不可以访问 ，子类不可以访问
        protected 保护   类内可以访问，类外不可以访问，子类可以访问
      隐藏的作用
        设置私有成员的机制就叫做“隐藏”，隐藏的目的是强制对私有变量的成员访问一定要通过公有函数进行，这样做的好处是：如果修改了私有成员变量的类型属性等，只需要修改成员函数即可，否则需要修改所有访问成员变量的语句。

    七，标识符的作用域与可见性
      不重要后面学

### 第三章：类和对象进阶
    一，构造函数和析构函数（看书本重新学习，只是粗略的过了一遍）
      构造函数：
        主要作用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用。（对象的初始化）
      析构函数：
        主要作用于对象销毁前系统自动调用，执行一些清理工作。
      构造函数语法：类名（）{}
        1.构造函数没有返回值，也不写void。
        2.函数名称与类名相同。
        3.构造函数可以有参数因此可以重载。
        4.程序在调用对象时候会自动调用构造，无需手动调用，而且只会调用一次。
      析构函数语法：~类名（）{}
        1.析构函数，没有返回值也不写void
        2.函数名称和类名相同，在名称前加符号~
        3.析构函数不能有参数，因此不能重载
        4.析构函数在对象销毁前会自动调用，无需手动，且只会调用一次
      构造函数的分类及调用
        两种分类方式：
          按参数分为：有参构造和无参构造
          按类型分为：普通构造，和拷贝构造
            拷贝构造：Person（const Person &p）{}
        三种调用方式：
          括号法
                Person P1；调用默认
                Person P2（10）；调用有参
                Person P3（P1）；调用拷贝
          显示法
                Person P1；调用默认
                Person P2 = Person （10）；调用有参
                Person P3 = Person （P1）；调用拷贝
          隐式转换法
                Person P4 = 10 ；
                Person P5 = P4；
                
    三，类的静态成员（在成员变量和成员函数前加上static）
      类的静态成员
        静态成员变量
          1.所有对象共享同一份数据
          2.在编译阶段分配内存
          3.类内声明，类外初始化
        给静态成员变量赋值和访问的格式如下：
          赋值：     类型 类名：：静态成员变量=初值；
          访问：     类名：：静态成员名 或    对象名.静态成员名
        静态成员函数
          1.所有对象共享同一个函数
          2.静态成员函数只能访问静态成员变量
          
    四，变量及对象的生存期和作用域
      没学

    五，常量成员和常引用成员
      没学
    六，成员对象和封闭类
      没学
      
    七，友元
      友元的目的就是让一个函数或者类，访问另一个类中的私有成员
            友元的关键字为 friend
            友元的三种实现
              1.全局函数做友元
              2.类做友元
              3.成员函数做友元
      友元函数
        把全局函数前面加上friend 放在类里面就可以访问类的私有成员。
        把成员函数复制过去，前面加上friend然后写上写上属于哪个类。
      友元类
        把类前面加上friend放在要访问的类里面就可以访问类的私有成员。
        
    八，this指针
      概念
        this指针指向被调用的成员函数所属的对象。
        this指针是隐含每一个非静态成员函数内的一种指针。
        this指针不需要定义，直接使用即可。
      用途
        当形参和成员变量同名时，可用this指针来区分
        在类的非静态成员函数中返回对象本身，可使用return*this

### 第四章：运算符重载
    一，运算符重载的概念
      对已有的运算符重新定义，赋于其另一种功能，以适应不同类型的数据。

      重载+或者-
      写一个operator+的成员函数或者全局函数就可以实现两个对象的属性相加。    
        成员函数重载Person operator+ (Porson &p)  减法就换一下符号就行
              {
                Person temp;
                temp.a = this->a + p.a;
                temp.b = this->b + p.b;
                return temp;
              }

    二，重载赋值运算符
      编译器提供的赋值运算符是浅拷贝操作，要使用深拷贝就得使用运算符重载。
        Person & opertor=(Person &p)
        {
          if(age!=NULL)
          {
            delete age;
            age = NULL;
          }
          return *this;
          int age;
        }
      
    三，重载流插入和流提取运算符
      作用就是可以输出自定义数据类型，原理和上面一样，
      想用cout<<p 的格式输出必须用全局函数实现
      ostrem & operator<<(ostrem& cout,Person &p)
      {
        cout<<p.a<<p.b;
        return cout;
      }

    四，重载自增自减运算符
      前置递增：
          int num;
          my integer()
          {
            num = 0;
          }
          
          my integer& operaor++ ()
          {
            num++;
            return *this;
          }
          
      后置递增： 后置递增返回的是值，前置递增返回引用。
          int num;
          my integer()
          {
            num = 0;
          }
          
          my integer operaor++ (int) 这个int代表站位参数，用来区分前置后置递增。
          {
            my integer temp = *this ；
            num++；
            return temp;
          }

### 第五章：类的继承与派生
    一，继承的语法
      继承的优点是大量减少代码，提高代码复用性。
      语法： class 子类 ：继承方式 父类
      
    二，继承方式
      分为公共继承和保护继承，私有继承，不管怎么继承都是无法访问父类的private。
        公共继承 public ：父类的公共 保护不变直接继承。
        保护继承 protected ：父类的公共和保护都变成保护。
        私有继承 pirvate : 父类的公共和保护都变成私有。
      父类的私有也是被子类给继承过去了，只不过编译器给隐藏了。
      父类和子类的构造和析构顺序是父类先构造，子类先析构。
      
    三，多继承语法
      语法：class 子类 ：继承方式 父类1，继承方式 父类2，继承方式 父类3…
      多继承会引起父类中有同名成员 使用时用作用域进行区分 父类1：：

### 第六章：多态与虚函数
    一，
      virtual关键字代表虚的意思，加在函数前面就是虚函数
      动态多态是地址晚绑定，静态是地址早绑定。
      动态多态满足条件：
        1，有继承关系
        2，子类要重写父类的虚函数
      动态多态的使用：
        父类的指针或者引用，指向子类对象
        
    二，纯虚函数和抽象类
      在多态中，通常父类的虚函数是没有意义的，主要是调用子类重写的内容，因此可以将虚函数改为纯虚函数  
          语法：virtual 返回值类型 函数名 （参数列表）= 0
      当类中有了纯虚函数，这个类也称为抽象类。
      抽象类特点：
            1.无法实例化对象
    2.子类必须重写抽象类中的纯虚函数，否则也属于抽象类




